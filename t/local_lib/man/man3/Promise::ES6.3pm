.\" Automatically generated by Pod::Man 4.07 (Pod::Simple 3.32)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.if !\nF .nr F 0
.if \nF>0 \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    if !\nF==2 \{\
.        nr % 0
.        nr F 2
.    \}
.\}
.\" ========================================================================
.\"
.IX Title "Promise::ES6 3pm"
.TH Promise::ES6 3pm "2020-04-20" "perl v5.24.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Promise::ES6 \- ES6\-style promises in Perl
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Promise::ES6;
\&
\&    # OPTIONAL. And see below for other options.
\&    Promise::ES6::use_event(\*(AqIO::Async\*(Aq, $loop);
\&
\&    my $promise = Promise::ES6\->new( sub {
\&        my ($resolve_cr, $reject_cr) = @_;
\&
\&        # ..
\&    } );
\&
\&    my $promise2 = $promise\->then( sub { .. }, sub { .. } );
\&
\&    my $promise3 = $promise\->catch( sub { .. } );
\&
\&    my $promise4 = $promise\->finally( sub { .. } );
\&
\&    my $resolved = Promise::ES6\->resolve(5);
\&    my $rejected = Promise::ES6\->reject(\*(Aqnono\*(Aq);
\&
\&    my $all_promise = Promise::ES6\->all( \e@promises );
\&
\&    my $race_promise = Promise::ES6\->race( \e@promises );
\&
\&    my $allsettled_promise = Promise::ES6\->allSettled( \e@promises );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module provides a Perl implementation of promises <https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_promises>, a useful pattern
for coordinating asynchronous tasks.
.PP
Unlike most other promise implementations on \s-1CPAN,\s0 this module
mimics ECMAScript 6’s Promise <https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise>
interface. As the \s-1SYNOPSIS\s0 above shows, you can thus use patterns from
JavaScript in Perl with only minimal changes needed to accommodate language
syntax.
.PP
This is a rewrite of an earlier module, Promise::Tiny. It fixes several
bugs and superfluous dependencies in the original.
.SH "STATUS"
.IX Header "STATUS"
This module is in use in production and, backed by a pretty extensive
set of regression tests, may be considered stable.
.SH "INTERFACE NOTES"
.IX Header "INTERFACE NOTES"
.IP "\(bu" 4
Promise resolutions and rejections accept exactly one argument,
not a list.
.IP "\(bu" 4
Unhandled rejections are reported via \f(CW\*(C`warn()\*(C'\fR. (See below
for details.)
.IP "\(bu" 4
The Promises/A+ test suite <https://github.com/promises-aplus/promises-tests> avoids testing the case where an “executor”
function’s resolve callback itself receives another promise, e.g.:
.Sp
.Vb 3
\&    my $p = Promise::ES6\->new( sub ($res) {
\&        $res\->( Promise::ES6\->resolve(123) );
\&    } );
.Ve
.Sp
What will \f(CW$p\fR’s resolution value be? 123, or the promise that wraps it?
.Sp
This module favors conformity with the \s-1ES6\s0 standard, which
indicates intent <https://www.ecma-international.org/ecma-262/6.0/#sec-promise-executor> that \f(CW$p\fR’s resolution value be 123.
.SH "COMPATIBILITY"
.IX Header "COMPATIBILITY"
This module considers any object that has a \f(CW\*(C`then()\*(C'\fR method to be a promise.
Note that, in the case of Future, this will yield a “false\-positive”, as
Future is not compatible with promises.
.PP
(See Promise::ES6::Future for more tools to interact with Future.)
.SH "UNHANDLED REJECTIONS"
.IX Header "UNHANDLED REJECTIONS"
This module’s handling of unhandled rejections has changed over time.
The current behavior is: if any rejected promise is DESTROYed without first
having received a catch callback, a warning is thrown.
.SH "SYNCHRONOUS VS. ASYNCHRONOUS OPERATION"
.IX Header "SYNCHRONOUS VS. ASYNCHRONOUS OPERATION"
In JavaScript, the following …
.PP
.Vb 2
\&    Promise.resolve().then( () => console.log(1) );
\&    console.log(2);
.Ve
.PP
… will log \f(CW2\fR then \f(CW1\fR because JavaScript’s \f(CW\*(C`then()\*(C'\fR defers execution
of its callbacks until between iterations through JavaScript’s event loop.
.PP
Perl, of course, has no built-in event loop. This module accommodates that by
implementing \fBsynchronous\fR promises by default rather than asynchronous ones.
This means that all promise callbacks run \fIimmediately\fR rather than between
iterations of an event loop. As a result, this:
.PP
.Vb 2
\&    Promise::ES6\->resolve(0)\->then( sub { print 1 } );
\&    print 2;
.Ve
.PP
… will print \f(CW12\fR instead of \f(CW21\fR.
.PP
One effect of this is that Promise::ES6, in its default configuration, is
agnostic regarding event loop interfaces: no special configuration is needed
for any specific event loop. In fact, you don’t even \fIneed\fR an event loop
at all, which might be useful for abstracting over whether a given
function works synchronously or asynchronously.
.PP
The disadvantage of synchronous promises—besides not being \fIquite\fR the same
promises that we expect from JS—is that recursive promises can exceed
call stack limits. For example, the following (admittedly contrived) code:
.PP
.Vb 1
\&    my @nums = 1 .. 1000;
\&
\&    sub _remove {
\&        if (@nums) {
\&            Promise::ES6\->resolve(shift @nums)\->then(\e&_remove);
\&        }
\&    }
\&
\&    _remove();
.Ve
.PP
… will eventually fail because it will reach Perl’s call stack size limit.
.PP
That problem probably won’t affect most applications. The best way to
avoid it, though, is to use asynchronous promises, à la JavaScript.
.PP
To do that, first choose one of the following event interfaces:
.IP "\(bu" 4
IO::Async
.IP "\(bu" 4
AnyEvent
.IP "\(bu" 4
Mojo::IOLoop (part of Mojolicious)
.PP
Then, before you start creating promises, do this:
.PP
.Vb 1
\&    Promise::ES6::use_event(\*(AqAnyEvent\*(Aq);
.Ve
.PP
… or:
.PP
.Vb 1
\&    Promise::ES6::use_event(\*(AqMojo::IOLoop\*(Aq);
.Ve
.PP
… or:
.PP
.Vb 1
\&    Promise::ES6::use_event(\*(AqIO::Async\*(Aq, $loop);
.Ve
.PP
That’s it! Promise::ES6 instances will now work asynchronously rather than
synchronously.
.PP
Note that this changes Promise::ES6 \fIglobally\fR. In IO::Async’s case, it
won’t increase the passed-in IO::Async::Loop instance’s reference count,
but if that loop object goes away, Promise::ES6 won’t work until you call
\&\f(CW\*(C`use_event()\*(C'\fR again.
.PP
\&\fB\s-1IMPORTANT:\s0\fR For the best long-term scalability and flexibility,
your code should work with either synchronous or asynchronous promises.
.SH "CANCELLATION"
.IX Header "CANCELLATION"
Promises have never provided a standardized solution for cancellation—i.e.,
aborting an in-process operation. If you need this functionality, then, you’ll
have to implement it yourself. Two ways of doing this are:
.IP "\(bu" 4
Subclass Promise::ES6 and provide cancellation logic in that
subclass. See DNS::Unbound::AsyncQuery’s implementation for an
example of this.
.IP "\(bu" 4
Implement the cancellation on a request object that your
“promise\-creator” also consumes. This is probably the more straightforward
approach but requires that there
be some object or \s-1ID\s0 besides the promise that uniquely identifies the action
to be canceled. See Net::Curl::Promiser for an example of this approach.
.PP
You’ll need to decide if it makes more sense for your application to leave
a canceled query in the “pending” state or to “settle” (i.e., resolve or
reject) it. All things being equal, I feel the first approach is the most
intuitive, while the latter ends up being “cleaner”.
.SH "MEMORY LEAKS"
.IX Header "MEMORY LEAKS"
It’s easy to create inadvertent memory leaks using promises in Perl.
Here are a few “pointers” (heh) to bear in mind:
.IP "\(bu" 4
Any Promise::ES6 instances that are created while
\&\f(CW$Promise::ES6::DETECT_MEMORY_LEAKS\fR is set to a truthy value are
“leak\-detect\-enabled”, which means that if they survive until their original
process’s global destruction, a warning is triggered. You should normally
enable this flag in a development environment.
.IP "\(bu" 4
If your application needs recursive promises (e.g., to poll
iteratively for completion of a task), the \f(CW\*(C`current_sub\*(C'\fR feature (i.e.,
\&\f(CW\*(C`_\|_SUB_\|_\*(C'\fR) may help you avoid memory leaks. In Perl versions that don’t
support this feature (i.e., anything pre\-5.16) you can imitate it thus:
.Sp
.Vb 1
\&    use constant _has_current_sub => eval "use feature \*(Aqcurrent_sub\*(Aq";
\&
\&    use if _has_current_sub(), feature => \*(Aqcurrent_sub\*(Aq;
\&
\&    my $cb;
\&    $cb = sub {
\&        my $current_sub = do {
\&            no strict \*(Aqsubs\*(Aq;
\&            _has_current_sub() ? _\|_SUB_\|_ : eval \*(Aq$cb\*(Aq;
\&        };
\&    }
.Ve
.Sp
Of course, it’s better if you can avoid doing that. :)
.IP "\(bu" 4
Garbage collection before Perl 5.18 seems to have been buggy.
If you work with such versions and end up chasing leaks,
try manually deleting as many references/closures as possible. See
\&\fIt/race_success.t\fR for a notated example.
.Sp
You may also (counterintuitively, \s-1IMO\s0) find that this:
.Sp
.Vb 1
\&    my ($resolve, $reject);
\&
\&    my $promise = Promise::ES6\->new( sub { ($resolve, $reject) = @_ } );
\&
\&    # … etc.
.Ve
.Sp
… works better than:
.Sp
.Vb 2
\&    my $promise = Promise::ES6\->new( sub {
\&        my ($resolve, $reject) = @_;
\&
\&        # … etc.
\&    } );
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
If you’re not sure of what promises are, there are several good
introductions to the topic. You might start with
this one <https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_promises>.
.PP
Promise::XS is my refactor of AnyEvent::XSPromises. It’s a lot like
this library but implemented mostly in \s-1XS\s0 for speed.
.PP
Promises is another pure-Perl Promise implementation.
.PP
Future fills a role similar to that of promises. Much of the IO::Async
ecosystem assumes (or strongly encourages) its use.
.PP
\&\s-1CPAN\s0 contains a number of other modules that implement promises. I think
mine are the nicest :), but \s-1YMMV.\s0 Enjoy!
.SH "LICENSE & COPYRIGHT"
.IX Header "LICENSE & COPYRIGHT"
Copyright 2019\-2020 Gasper Software Consulting.
.PP
This library is licensed under the same terms as Perl itself.
